using System.Text;
using Microsoft.CodeAnalysis;
using Tenekon.MethodOverloads.SourceGenerator.Model;

namespace Tenekon.MethodOverloads.SourceGenerator.SourceFormatting;

internal static partial class SourceFormatter
{
    private static void EmitMethods(SourceProductionContext context, GenerationResult result)
    {
        foreach (var pair in result.MethodsByNamespace)
        {
            var namespaceName = pair.Key;
            var methods = pair.Value;
            var builder = new StringBuilder();
            builder.AppendLine("// <auto-generated/>");
            builder.AppendLine("#nullable enable");
            builder.AppendLine();

            if (!string.IsNullOrWhiteSpace(namespaceName))
            {
                builder.Append("namespace ").Append(namespaceName).AppendLine(";");
                builder.AppendLine();
            }

            AppendMatcherUsageAttributes(builder, result, namespaceName, string.Empty);
            builder.AppendLine("public static class MethodOverloads");
            builder.AppendLine("{");

            foreach (var generated in methods.OrderBy(m => m.Method.Name, StringComparer.Ordinal))
            {
                builder.AppendLine(generated.Render());
            }

            builder.AppendLine("}");

            context.AddSource($"MethodOverloads_{Sanitize(namespaceName)}.g.cs", builder.ToString());
        }

        EmitMatcherUsageStubs(context, result);
    }

    private static void EmitMatcherUsageStubs(SourceProductionContext context, GenerationResult result)
    {
        foreach (var pair in result.MatchedMatchersByNamespace)
        {
            var namespaceName = pair.Key;
            var matchedMatchers = pair.Value;
            if (matchedMatchers.Count == 0)
            {
                continue;
            }

            if (result.MethodsByNamespace.ContainsKey(namespaceName))
            {
                continue;
            }

            var builder = new StringBuilder();
            builder.AppendLine("// <auto-generated/>");
            builder.AppendLine("#nullable enable");
            builder.AppendLine();

            if (!string.IsNullOrWhiteSpace(namespaceName))
            {
                builder.Append("namespace ").Append(namespaceName).AppendLine(";");
                builder.AppendLine();
            }

            AppendMatcherUsageAttributes(builder, result, namespaceName, string.Empty);
            builder.AppendLine("public static class MethodOverloads");
            builder.AppendLine("{");
            builder.AppendLine("}");

            context.AddSource($"MethodOverloads_{Sanitize(namespaceName)}_MatcherUsage.g.cs", builder.ToString());
        }
    }

    private static void AppendMatcherUsageAttributes(StringBuilder builder, GenerationResult result, string namespaceName, string indent)
    {
        if (!result.MatchedMatchersByNamespace.TryGetValue(namespaceName, out var matchedMatchers) ||
            matchedMatchers.Count == 0)
        {
            return;
        }

        foreach (var matcherMethod in GeneratedMethod.NormalizeMatchedMatcherMethods(matchedMatchers))
        {
            var identifier = matcherMethod.ContainingTypeDisplay + "." + matcherMethod.MethodName;
            builder.Append(indent)
                .Append("[global::Tenekon.MethodOverloads.SourceGenerator.MatcherUsageAttribute(nameof(")
                .Append(identifier)
                .Append("))]")
                .AppendLine();
        }
    }

    private static string Sanitize(string name)
    {
        if (string.IsNullOrEmpty(name))
        {
            return "Global";
        }

        var builder = new StringBuilder(name.Length);
        foreach (var ch in name)
        {
            builder.Append(char.IsLetterOrDigit(ch) ? ch : '_');
        }

        return builder.ToString();
    }
}
