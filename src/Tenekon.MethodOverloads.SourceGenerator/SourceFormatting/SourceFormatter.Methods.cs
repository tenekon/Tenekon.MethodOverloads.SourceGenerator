using System.Text;
using Microsoft.CodeAnalysis;
using Tenekon.MethodOverloads.SourceGenerator.Generation;

namespace Tenekon.MethodOverloads.SourceGenerator.SourceFormatting;

internal static partial class SourceFormatter
{
    private static void EmitMethods(SourceProductionContext context, OverloadPlan plan)
    {
        foreach (var pair in plan.MethodsByNamespace)
        {
            var namespaceName = pair.Key;
            var methods = pair.Value;
            var builder = new StringBuilder();
            builder.AppendLine("// <auto-generated/>");
            builder.AppendLine("#nullable enable");
            builder.AppendLine();

            if (!string.IsNullOrWhiteSpace(namespaceName))
            {
                builder.Append("namespace ").Append(namespaceName).AppendLine(";");
                builder.AppendLine();
            }

            AppendMatcherUsageAttributes(builder, plan, namespaceName, string.Empty);
            builder.AppendLine("public static class MethodOverloads");
            builder.AppendLine("{");

            foreach (var planned in methods.OrderBy(m => m.Method.Name, StringComparer.Ordinal))
            {
                var generated = new GeneratedMethod(
                    planned.Method,
                    planned.KeptParameters,
                    planned.OmittedParameters,
                    planned.OverloadVisibility,
                    planned.MatchedMatcherMethods);
                builder.AppendLine(generated.Render());
            }

            builder.AppendLine("}");

            context.AddSource($"MethodOverloads_{Sanitize(namespaceName)}.g.cs", builder.ToString());
        }

        EmitMatcherUsageStubs(context, plan);
    }

    private static void EmitMatcherUsageStubs(SourceProductionContext context, OverloadPlan plan)
    {
        foreach (var pair in plan.MatchedMatchersByNamespace)
        {
            var namespaceName = pair.Key;
            var matchedMatchers = pair.Value;
            if (matchedMatchers.Count == 0) continue;

            if (plan.MethodsByNamespace.ContainsKey(namespaceName)) continue;

            var builder = new StringBuilder();
            builder.AppendLine("// <auto-generated/>");
            builder.AppendLine("#nullable enable");
            builder.AppendLine();

            if (!string.IsNullOrWhiteSpace(namespaceName))
            {
                builder.Append("namespace ").Append(namespaceName).AppendLine(";");
                builder.AppendLine();
            }

            AppendMatcherUsageAttributes(builder, plan, namespaceName, string.Empty);
            builder.AppendLine("public static class MethodOverloads");
            builder.AppendLine("{");
            builder.AppendLine("}");

            context.AddSource($"MethodOverloads_{Sanitize(namespaceName)}_MatcherUsage.g.cs", builder.ToString());
        }
    }

    private static void AppendMatcherUsageAttributes(
        StringBuilder builder,
        OverloadPlan plan,
        string namespaceName,
        string indent)
    {
        if (!plan.MatchedMatchersByNamespace.TryGetValue(namespaceName, out var matchedMatchers)
            || matchedMatchers.Count == 0)
            return;

        foreach (var matcherMethod in GeneratedMethod.NormalizeMatchedMatcherMethods(matchedMatchers))
        {
            var identifier = matcherMethod.ContainingTypeDisplay + "." + matcherMethod.MethodName;
            builder.Append(indent)
                .Append("[global::Tenekon.MethodOverloads.SourceGenerator.MatcherUsageAttribute(nameof(")
                .Append(identifier)
                .Append("))]")
                .AppendLine();
        }
    }

    private static string Sanitize(string name)
    {
        if (string.IsNullOrEmpty(name)) return "Global";

        var builder = new StringBuilder(name.Length);
        foreach (var ch in name) builder.Append(char.IsLetterOrDigit(ch) ? ch : '_');

        return builder.ToString();
    }
}