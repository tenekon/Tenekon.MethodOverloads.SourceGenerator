using System.Text;
using Microsoft.CodeAnalysis;
using Tenekon.MethodOverloads.SourceGenerator.Generation;
using Tenekon.MethodOverloads.SourceGenerator.Models;

namespace Tenekon.MethodOverloads.SourceGenerator.SourceFormatting;

internal static partial class SourceFormatter
{
    private static void EmitMethods(SourceProductionContext context, OverloadPlan plan)
    {
        foreach (var pair in plan.MethodsByGroup.OrderBy(p => p.Key.Namespace, StringComparer.Ordinal)
                     .ThenBy(p => p.Key.BucketName, StringComparer.Ordinal))
        {
            var groupKey = pair.Key;
            var namespaceName = groupKey.Namespace;
            var methods = pair.Value;
            var builder = new StringBuilder();
            builder.AppendLine("// <auto-generated/>");
            builder.AppendLine("#nullable enable");
            builder.AppendLine();

            if (!string.IsNullOrWhiteSpace(namespaceName))
            {
                builder.Append("namespace ").Append(namespaceName).AppendLine(";");
                builder.AppendLine();
            }

            AppendMatcherUsageAttributes(builder, plan, groupKey, string.Empty);
            var bucketType = methods.Count > 0 ? methods[0].BucketType : (BucketTypeModel?)null;
            builder.AppendLine(RenderClassDeclaration(groupKey, bucketType));
            builder.AppendLine("{");

            foreach (var planned in methods.OrderBy(m => m.Method.Name, StringComparer.Ordinal))
            {
                var generated = new GeneratedMethod(
                    planned.Method,
                    planned.KeptParameters,
                    planned.OmittedParameters,
                    planned.OverloadVisibility,
                    planned.MatchedMatcherMethods);
                builder.AppendLine(generated.Render());
            }

            builder.AppendLine("}");

            context.AddSource(BuildFileName(groupKey, isMatcherUsageStub: false), builder.ToString());
        }

        EmitMatcherUsageStubs(context, plan);
    }

    private static void EmitMatcherUsageStubs(SourceProductionContext context, OverloadPlan plan)
    {
        foreach (var pair in plan.MatchedMatchersByGroup.OrderBy(p => p.Key.Namespace, StringComparer.Ordinal)
                     .ThenBy(p => p.Key.BucketName, StringComparer.Ordinal))
        {
            var groupKey = pair.Key;
            var matchedMatchers = pair.Value;
            if (matchedMatchers.MatchedMatchers.Count == 0) continue;

            if (plan.MethodsByGroup.ContainsKey(groupKey)) continue;

            var namespaceName = groupKey.Namespace;

            var builder = new StringBuilder();
            builder.AppendLine("// <auto-generated/>");
            builder.AppendLine("#nullable enable");
            builder.AppendLine();

            if (!string.IsNullOrWhiteSpace(namespaceName))
            {
                builder.Append("namespace ").Append(namespaceName).AppendLine(";");
                builder.AppendLine();
            }

            AppendMatcherUsageAttributes(builder, plan, groupKey, string.Empty);
            builder.AppendLine(RenderClassDeclaration(groupKey, matchedMatchers.BucketType));
            builder.AppendLine("{");
            builder.AppendLine("}");

            context.AddSource(BuildFileName(groupKey, isMatcherUsageStub: true), builder.ToString());
        }
    }

    private static void AppendMatcherUsageAttributes(
        StringBuilder builder,
        OverloadPlan plan,
        OverloadGroupKey groupKey,
        string indent)
    {
        if (!plan.MatchedMatchersByGroup.TryGetValue(groupKey, out var matchedMatchers)
            || matchedMatchers.MatchedMatchers.Count == 0)
            return;

        foreach (var matcherMethod in GeneratedMethod.NormalizeMatchedMatcherMethods(matchedMatchers.MatchedMatchers))
        {
            if (!ShouldEmitMatcherUsage(matcherMethod)) continue;

            var identifier = matcherMethod.ContainingTypeDisplay + "." + matcherMethod.MethodName;
            if (identifier.Contains("<", StringComparison.Ordinal))
            {
                var literal = identifier.Replace("\\", "\\\\").Replace("\"", "\\\"");
                builder.Append(indent)
                    .Append("[global::Tenekon.MethodOverloads.MatcherUsageAttribute(\"")
                    .Append(literal)
                    .Append("\")]")
                    .AppendLine();
            }
            else
            {
                builder.Append(indent)
                    .Append("[global::Tenekon.MethodOverloads.MatcherUsageAttribute(nameof(")
                    .Append(identifier)
                    .Append("))]")
                    .AppendLine();
            }
        }
    }

    private static string Sanitize(string name)
    {
        if (string.IsNullOrEmpty(name)) return "Global";

        var builder = new StringBuilder(name.Length);
        foreach (var ch in name) builder.Append(char.IsLetterOrDigit(ch) ? ch : '_');

        return builder.ToString();
    }

    private static string BuildFileName(OverloadGroupKey groupKey, bool isMatcherUsageStub)
    {
        var namespacePart = Sanitize(groupKey.Namespace);
        var bucketPart = groupKey.IsDefault ? string.Empty : "_" + Sanitize(groupKey.BucketName);
        var stubPart = isMatcherUsageStub ? "_MatcherUsage" : string.Empty;
        return $"MethodOverloads_{namespacePart}{bucketPart}{stubPart}.g.cs";
    }

    private static string RenderClassDeclaration(OverloadGroupKey groupKey, BucketTypeModel? bucketType)
    {
        if (groupKey.IsDefault) return "public static class MethodOverloads";

        var accessibility = bucketType.HasValue
            ? RenderTypeAccessibility(bucketType.Value.Accessibility)
            : "public";

        return accessibility + " static partial class " + groupKey.BucketName;
    }

    private static string RenderTypeAccessibility(Accessibility accessibility)
    {
        return accessibility == Accessibility.Public ? "public" : "internal";
    }

    private static bool ShouldEmitMatcherUsage(MatcherMethodReference matcherMethod)
    {
        return matcherMethod.ContainingTypeAccessibility == Accessibility.Public
            || matcherMethod.ContainingTypeAccessibility == Accessibility.Internal
            || matcherMethod.ContainingTypeAccessibility == Accessibility.ProtectedOrInternal
            || matcherMethod.ContainingTypeAccessibility == Accessibility.NotApplicable;
    }
}
