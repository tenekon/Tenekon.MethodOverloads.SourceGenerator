using System.Text;
using Microsoft.CodeAnalysis;

namespace Tenekon.MethodOverloads.SourceGenerator;

internal sealed partial class MethodOverloadsGeneratorCore
{
    /// <summary>
    /// Emits generated extension methods into source files.
    /// </summary>
    private void EmitMethods()
    {
        foreach (var pair in _methodsByNamespace)
        {
            var namespaceName = pair.Key;
            var methods = pair.Value;
            var builder = new StringBuilder();
            builder.AppendLine("// <auto-generated/>");
            builder.AppendLine("#nullable enable");
            builder.AppendLine();

            if (!string.IsNullOrWhiteSpace(namespaceName))
            {
                builder.Append("namespace ").Append(namespaceName).AppendLine(";");
                builder.AppendLine();
            }

            AppendMatcherUsageAttributes(builder, namespaceName, string.Empty);
            builder.AppendLine("public static class MethodOverloads");
            builder.AppendLine("{");

            foreach (var generated in methods.OrderBy(m => m.Method.Name, StringComparer.Ordinal))
            {
                builder.AppendLine(generated.Render());
            }

            builder.AppendLine("}");

            _context.AddSource($"MethodOverloads_{Sanitize(namespaceName)}.g.cs", builder.ToString());
        }

        EmitMatcherUsageStubs();
    }

    private void EmitMatcherUsageStubs()
    {
        foreach (var pair in _matchedMatchersByNamespace)
        {
            var namespaceName = pair.Key;
            var matchedMatchers = pair.Value;
            if (matchedMatchers.Count == 0)
            {
                continue;
            }

            if (_methodsByNamespace.ContainsKey(namespaceName))
            {
                continue;
            }

            var builder = new StringBuilder();
            builder.AppendLine("// <auto-generated/>");
            builder.AppendLine("#nullable enable");
            builder.AppendLine();

            if (!string.IsNullOrWhiteSpace(namespaceName))
            {
                builder.Append("namespace ").Append(namespaceName).AppendLine(";");
                builder.AppendLine();
            }

            AppendMatcherUsageAttributes(builder, namespaceName, string.Empty);
            builder.AppendLine("public static class MethodOverloads");
            builder.AppendLine("{");
            builder.AppendLine("}");

            _context.AddSource($"MethodOverloads_{Sanitize(namespaceName)}_MatcherUsage.g.cs", builder.ToString());
        }
    }

    private void AppendMatcherUsageAttributes(StringBuilder builder, string namespaceName, string indent)
    {
        if (!_matchedMatchersByNamespace.TryGetValue(namespaceName, out var matchedMatchers) ||
            matchedMatchers.Count == 0)
        {
            return;
        }

        foreach (var matcherMethod in GeneratedMethod.NormalizeMatchedMatcherMethods(matchedMatchers))
        {
            builder.Append(indent)
                .Append("[global::Tenekon.MethodOverloads.SourceGenerator.MatcherUsageAttribute(nameof(")
                .Append(matcherMethod.MethodName)
                .Append("))]")
                .AppendLine();
        }
    }

    private static string Sanitize(string name)
    {
        if (string.IsNullOrEmpty(name))
        {
            return "Global";
        }

        var builder = new StringBuilder(name.Length);
        foreach (var ch in name)
        {
            builder.Append(char.IsLetterOrDigit(ch) ? ch : '_');
        }

        return builder.ToString();
    }

    private static string BuildMethodGroupKey(MethodModel method)
    {
        var builder = new StringBuilder();
        builder.Append(method.ContainingTypeDisplay);
        builder.Append(".");
        builder.Append(method.Name);
        builder.Append("|");
        builder.Append(method.TypeParameterCount);

        foreach (var parameter in method.Parameters.Items)
        {
            builder.Append("|");
            builder.Append(parameter.TypeDisplay);
            builder.Append(":");
            builder.Append(parameter.RefKind);
            builder.Append(":");
            builder.Append(parameter.IsParams ? "params" : "noparams");
        }

        return builder.ToString();
    }

    private static int Clamp(int value, int min, int max)
    {
        if (value < min)
        {
            return min;
        }

        if (value > max)
        {
            return max;
        }

        return value;
    }
}
