using System.Text;
using Microsoft.CodeAnalysis;

namespace Tenekon.MethodOverloads.SourceGenerator;

internal sealed partial class MethodOverloadsGeneratorCore
{
    /// <summary>
    /// Emits generated extension methods into source files.
    /// </summary>
    private void EmitMethods()
    {
        foreach (var pair in _methodsByNamespace)
        {
            var namespaceName = pair.Key;
            var methods = pair.Value;
            var builder = new StringBuilder();
            builder.AppendLine("// <auto-generated/>");
            builder.AppendLine("#nullable enable");
            builder.AppendLine();

            if (!string.IsNullOrWhiteSpace(namespaceName))
            {
                builder.Append("namespace ").Append(namespaceName).AppendLine(";");
                builder.AppendLine();
            }

            builder.AppendLine("public static class MethodOverloads");
            builder.AppendLine("{");

            foreach (var generated in methods.OrderBy(m => m.Method.Name, StringComparer.Ordinal))
            {
                builder.AppendLine(generated.Render());
            }

            builder.AppendLine("}");

            _context.AddSource($"MethodOverloads_{Sanitize(namespaceName)}.g.cs", builder.ToString());
        }
    }
    private static string Sanitize(string name)
    {
        if (string.IsNullOrEmpty(name))
        {
            return "Global";
        }

        var builder = new StringBuilder(name.Length);
        foreach (var ch in name)
        {
            builder.Append(char.IsLetterOrDigit(ch) ? ch : '_');
        }

        return builder.ToString();
    }
    private static string BuildMethodGroupKey(IMethodSymbol method)
    {
        var builder = new StringBuilder();
        builder.Append(method.ContainingType.ToDisplayString(TypeDisplayFormat));
        builder.Append(".");
        builder.Append(method.Name);
        builder.Append("|");
        builder.Append(method.TypeParameters.Length);

        foreach (var parameter in method.Parameters)
        {
            builder.Append("|");
            builder.Append(parameter.Type.ToDisplayString(TypeDisplayFormat));
            builder.Append(":");
            builder.Append(parameter.RefKind);
            builder.Append(":");
            builder.Append(parameter.IsParams ? "params" : "noparams");
        }

        return builder.ToString();
    }
    private static int Clamp(int value, int min, int max)
    {
        if (value < min)
        {
            return min;
        }

        if (value > max)
        {
            return max;
        }

        return value;
    }
}

